import json
import os
import warnings
import re
from json2tex.InTextTagRenderer import InTextTagRenderer
from json2tex.StatBlockRenderer import StatBlockRenderer

'''
Main renderer class
'''
class DocumentRenderer:
    def __init__(self):
        self.lines = []
        self.setMeta("Untiteled Document", "", "Autogenerated")
        self.packages = [   {"name":"inputenc", "options":"utf8"},
                            "tabulary",
                            {"name":"ulem", "options":"normalem"},
                            "color,soul",
                            "float",
                            "caption",
                            "wrapfig",
                            {"name":"hyperref", "options":"colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black"}
                            ]
        self.additionalHeaderOptions = []
        self.contentData = []
        self.creatureData = []
        self.hasContentData = False
        self.hasCreatureData = False
        self.SubenvLvl = 0
        self.passedChapterHeading = False
        self.inAppendix = False

    def setMeta(self, title, subtitle, authors):
        self.title = title
        self.subtitle = subtitle
        self.authors = authors
        if self.subtitle == "": self.f_name = self.title.replace(" ", "_")
        else: self.f_name = "_-_".join([self.subtitle.replace(" ", "_"), self.title.replace(" ", "_")])
        self.temp_name = "_".join(["5eJSON2TEX",self.f_name])

    def setContentData(self, jsonPath):
        with open(jsonPath) as file:
            jsonData = json.load(file)
        self.contentData = jsonData.get("data")
        self.hasContentData = True

    def setCreatureData(self, jsonPath):
        with open(jsonPath) as file:
            jsonData = json.load(file)
        self.creatureData = jsonData.get("monster")
        self.hasCreatureData = True

    '''
    Writes the Latex header to the 'lines' container
    TODO
    '''
    def setUpDocument(self):
        self.lines.append( "\\documentclass[10pt,twoside,twocolumn,openany,nodeprecatedcode]{dndbook}" )
        for package in self.packages:
            if isinstance(package, str):
                self.lines.append( "\\usepackage{@PKG}".replace("@PKG", package) )
            else:
                self.lines.append( "\\usepackage[@OPTIONS]{@PKG}".replace("@PKG", package.get("name")).replace("@OPTIONS", package.get("options")) )
        self.lines.append( "\\title{@DOCUMENT_TITLE \\\\ \\large @DOCUMENT_SUBTITLE}".replace("@DOCUMENT_TITLE", self.title).replace("@DOCUMENT_SUBTITLE", self.subtitle))
        self.lines.append("\\author{@AUTHORS}".replace("@AUTHORS", self.authors))
        self.lines.extend(self.additionalHeaderOptions)
        self.lines.append("\\begin{document}")
        self.lines.append("\\maketitle")
        self.lines.append("\\addcontentsline{toc}{chapter}{Table Of Contents}")
        self.lines.append("\\tableofcontents")
        self.lines.append("\\newpage")

    '''
    Appends the final lines to the 'lines' container
    '''
    def closeDocument(self):
        end = "\\end{document}"
        self.lines.append(end)

    '''
    Writes the data in the 'lines' to a .tex file in order
    Input:
        adventureData: 'adventure' object from the JSON file, as a dict
    '''
    def writeTex(self):
        self.lines = [InTextTagRenderer.renderLine(line) for line in self.lines]
        with open(self.temp_name+".tex", 'w') as f:
            for line in self.lines:
                f.write(line + "\n")

    '''
    Calls pdflatex to convert the generated tex file to a pdf and clean up the output
    '''
    def convertToPdf(self):
        print("Compiling PDF from tex... (this can take a couple of seconnds)")
        os.system("pdflatex "+self.temp_name+".tex")
        os.system("pdflatex "+self.temp_name+".tex >/dev/null 2>&1")
        print("Cleaning up output files...")
        os.system("mv "+self.temp_name+".tex "+self.f_name+".tex")
        os.system("mv "+self.temp_name+".pdf "+self.f_name+".pdf")
        os.system("rm "+self.temp_name+"*")
        os.system("rm -r JSON2TEX_img")
        print("Done!")

    '''
    renders the document
    '''
    def render(self):
        self.setUpDocument()
        self.renderContent()
        self.closeDocument()
        self.writeTex()

    '''
    Renders adventure content to the 'lines' container
    Inputs:
        content: data object of the adventureData field in the JSON, as a dict.
    '''
    def renderContent(self):
        if self.hasContentData:
            for chapter in self.contentData:
                self.lines.extend(self.renderRecursive(0, chapter))
        else:
            self.lines.append("No content provided")

    '''
    Renders section and chapter headers, then proceedes to recursively loop through the data inside the 'entries' field, again calling renderRecursive with depth increased by 1.
    '''
    def renderSection(self, depth, data):
        titles = [
        "\\chapter{",
        "\\section{",
        "\\subsection{",
        "\\subsubsection{",
        "\\paragraph{",
        "\\subparagraph{"
        ]
        lines = []
        if depth == 0:
            self.passedChapterHeading = True
        if data.get("name") == "Appendix":
            lines += ["\\onecolumn"] 
            self.inAppendix = True
        if "name" in data:lines += [str(titles[depth] + data.get("name") + "} \\label{sec:" + data.get("name").replace(" ", "_") + "}")]
        for section in data.get("entries"):
            lines += self.renderRecursive(depth+1, section)
        return lines

    @staticmethod
    def getAlignmentsStr(alignments):
        alignKey = {"text-align-left":"X", "text-align-center":"c"}
        out = []
        for alignment in alignments:
            try:
                if alignment in alignKey: out.append(alignKey.get(alignment))
                elif alignment.startswith("col-"): 
                    width = float(alignment.replace("col-", "").replace(" text-center", "")) / 12
                    alignStr = ">{\hsize=@WIDTH\hsize}X".replace("@WIDTH", "%.3f" % width)
                    if alignment.endswith(" text-center"): alignStr = alignStr.replace("X", "c")
                    out.append(alignStr)
                else: out.append("X")
            except:
                out.append("X")
        return " ".join(out)
    '''
    Renders tables. Currently column content is written directly to the lines container without going through the renderer again.
    '''
    def renderTable(self, data):
        lines = []
        self.SubenvLvl += 1
        titles = data.get("colLabels")
        alignmentStr = self.getAlignmentsStr(data.get("colStyles"))
        print(alignmentStr)
        if "caption" in data: lines += [str("\\begin{DndTable}[header=@CAPTION]{ ".replace("@CAPTION", data.get("caption")) + alignmentStr + " }\n")]
        else: lines += ["\\begin{DndTable}{" + alignmentStr + "}\n"]
        if (titles): lines += [str(" & ".join(titles) + "\\\\")]
        for row in data.get("rows"):
            if isinstance(row, list): row = ["\n".join(self.renderRecursive(4, cell)) for cell in row]
            elif isinstance(row, dict): row = self.renderRecursive(4, row)
            lines += [" & ".join(row) + "\\\\"]
        lines += [str("\\end{DndTable}\n\n")]
        self.SubenvLvl -= 1
        return lines

    '''
    Renders an inset. The content of the inset is passed through renderRecursive again.
    '''
    def renderInset(self, depth, data):
        lines = []
        self.SubenvLvl += 1
        name = ""
        if "name" in data: name = data.get("name")
        lines += ["\\begin{DndComment}{" + name + "}"]
        for section in data.get("entries"):
            lines += self.renderRecursive(depth+1, section)
        lines += ["\\end{DndComment}\n"]
        self.SubenvLvl -= 1
        return lines

    '''
    Renders a read aloud inset. The content of the inset is passed through renderRecursive again.
    '''
    def renderReadAloudInset(self, depth, data):
        name = ""
        lines = []
        self.SubenvLvl += 1
        if "name" in data: name = data.get("name")
        lines += ["\\begin{DndReadAloud}{" + name + "}"]
        for section in data.get("entries"):
            lines += self.renderRecursive(depth+1, section)
        lines += ["\\end{DndReadAloud}\n"]
        self.SubenvLvl -= 1
        return lines

    '''
    Renders tables. Currently item content is written directly to the lines container without going through the renderer again.
    This means that 'item' objects will currently break this routine.
    Also list styles are currently ignored.
    '''
    def renderList(self, data):
        lines = []
        self.SubenvLvl += 1
        lines += ["\\begin{itemize}\n"]
        for item in data.get("items"):
            if (isinstance(item, str)): lines += ["\\item " + item.replace("&", "\\&").replace("&quot;", "\"").replace("_", "\_")]
        lines += ["\\end{itemize}\n\n"]
        self.SubenvLvl -= 1
        return lines

    '''
    Renders the quote environment.
    '''
    def renderQuote(self, data):
        lines = []
        self.SubenvLvl += 1
        lines += ["\\begingroup\n\\DndSetThemeColor[DmgLavender]\\begin{DndSidebar}{}"]
        lines += ["\\Large \centering «"]
        for line in data.get("entries"):
            lines += ["\\large \centering " + line + ""]
        lines += ["\\Large »\n \n \\normalsize \\raggedleft \\textit{ - " + data.get("by") + ", " + data.get("from")+"}"]
        lines += ["\\end{DndSidebar}\n\\endgroup"]
        self.SubenvLvl -= 1
        return lines

    '''
    Adds an image. Currently this will not work with remote images (ie. the standard in 5eJSONS - this is the only point where the standard 5eJSON syntax does not work).
    '''
    def renderImage(self, data):
        lines = []
        self.SubenvLvl += 1
        if data.get("href").get("type") == "external":
            try:
                import requests
                image_url = data.get("href").get("url")
                r = requests.get(image_url)
                os.system("mkdir ./JSON2TEX_img")
                file_name = "./JSON2TEX_img/" + str(hash(image_url))+".png"
                with open(file_name,'wb') as f:
                    f.write(r.content)
                lines += ["\\begingroup\n\\DndSetThemeColor[DmgLavender]\\begin{figure}[H]\n\\centering"]
                if self.inAppendix: lines += ["\includegraphics[width = 0.8 \\textwidth]{" + file_name + "}"]
                else: lines += ["\includegraphics[width = 0.4 \\textwidth]{" + file_name + "}"]
                if "title" in data or "credit" in data: 
                    caption = []
                    if "title" in data: caption.append(data.get("title"))
                    if "credit" in data: caption.append("\\textit{" + data.get("credit") + "}")
                    lines += ["\caption*{" + "\\\\ \\footnotesize Source: ".join(caption) + "}"]
                lines += ["\\end{figure}\n\\endgroup"]
            except:
                warnings.warn("\nSomething went wrong when rendering the image", category=RuntimeWarning)
        else: warnings.warn("\nImage rendering for 'internal' type not implemented", category=RuntimeWarning)
        self.SubenvLvl -= 1
        return lines

    '''
    Renders statblocks
    '''
    def renderStatblock(self, data):
        renderer = StatBlockRenderer()
        linesToAdd = []
        self.SubenvLvl += 1
        if not data.get("dataType") == "monster": return []
        if data.get("type") == "statblockInline": linesToAdd += renderer.renderInlineStatBlock(data.get("data"))
        elif data.get("type") == "statblock":
            if self.hasCreatureData:
                monsterFound = False
                for monster in self.creatureData:
                    if monster.get("name") == data.get("name"): 
                        linesToAdd += renderer.renderInlineStatBlock(monster)
                        monsterFound = True
                if not monsterFound: linesToAdd += ["Monster @MONSTERNAME not found in source".replace("@MONSTERNAME", data.get("name"))]
            else:
                linesToAdd += ["No creature data provided, cannot render Monster @MONSTERNAME".replace("@MONSTERNAME", data.get("name"))]
        self.SubenvLvl -= 1
        return linesToAdd

    def addDropCap(self, line):
        fs = re.compile(r"([^,.]+)")
        part = re.compile(r"^(.+)\s(.+)")
        fsentence = re.search(fs, line).group(1)
        if len(fsentence) > 35: replaceP = re.search(part, fsentence[0:35]).group(1)
        else: replaceP = fsentence
        new = "\\DndDropCapLine{" + replaceP.replace(replaceP[0], replaceP[0]+"}{", 1) + "}"
        line = line.replace(replaceP, new,1)
        self.passedChapterHeading = False
        return line + "\n"

    '''
    Main rendering routine. Can be called recursively.
    Reads the 'type' field of the 'data' input and
    Inputs:
        depth: recursion depth (used to detirmine the type of header: from chapter down to subparagraph)
        data: general JSON object
    '''
    def renderRecursive(self, depth, data):
        lines = []
        if isinstance(data, str):
            if self.passedChapterHeading and self.SubenvLvl == 0 and not self.inAppendix:
                data = self.addDropCap(data)
            lines += [data.replace("&", "\\&").replace("&quot;", "\"").replace("_", "\_").replace("%", "\%") ]
        elif isinstance(data, int):
            return self.renderRecursive(depth, str(data))
        elif data.get("type") == "section" or data.get("type") == "entries":
            lines += self.renderSection(depth, data)
        elif data.get("type") == "inset":
            lines += self.renderInset(depth, data)
        elif data.get("type") == "insetReadaloud":
            lines += self.renderReadAloudInset(depth, data)
        elif data.get("type") == "table":
            lines += self.renderTable(data)
        elif data.get("type") == "list":
            lines += self.renderList(data)
        elif data.get("type") == "quote":
            lines += self.renderQuote(data)
        elif data.get("type") == "image":
            lines += self.renderImage(data)
        elif data.get("type") == "statblockInline":
            lines += self.renderStatblock(data)
        elif data.get("type") == "statblock":
            lines += self.renderStatblock(data)
        elif data.get("type") == "row":
            lines.extend(data.get("row"))
        else:
            lines += ["NOT RENDERABLE TYPE: " + data.get("type")]
            warnings.warn("\nThe following type of JSON-Entry has not yet been implemented: " + data.get("type") + "\nThe entry will be skipped!", category=RuntimeWarning)
        return lines

